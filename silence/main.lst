gplink-0.13.7 beta
Copyright (c) 1998-2005 gputils project
Listing File Generated: 1-15-2011  13:06:53
 
 
Address  Value    Disassembly              Source
-------  -----    -----------              ------
                                           list P=18F4620, F=INHX32, C=160, N=80, ST=OFF, MM=OFF, R=DEC
                                           
                                           #include <p18f4620.inc>
                                                   LIST
                                           
                                           ;==========================================================================
                                           ;  MPASM PIC18F4620 processor include
                                           ; 
                                           ;  (c) Copyright 1999-2007 Microchip Technology, All rights reserved
                                           ;==========================================================================
                                           
                                                   NOLIST
                                           #include <macros.inc>
                                           ;
                                           ;  PIC macro library
                                           ;  Developed by Karl Lunt, May 1999
                                           ;
                                           
                                           ;
                                           ;  This library provides macros for program structures such
                                           ;  as FOR-NEXT, REPEAT-ALWAYS, REPEAT-UNTIL, and others.
                                           ;
                                           ;  To incorporate this library in your PIC assembler program,
                                           ;  add the following INCLUDE statement immediately after the
                                           ;  INCLUDE statement that adds the Microchip equates for your
                                           ;  specific processor:
                                           ;
                                           ;	include		"macros.asm"
                                           ;
                                           ;  For example, if you are developing code for the 12c672,
                                           ;  you would use equates similar to:
                                           ;
                                           ;	include		".\p12c672.inc"
                                           ;	include		".\macros.asm"
                                           ;
                                           
                                           ;
                                           ;  Version 1.0   29 May 1999
                                           ;  Initial release.  Includes WAITWHILE, WAITUNTIL, and POLL-ENDPOLL.
                                           ;  Changed movfw to movf, to support older MCUs.  Will still give errors
                                           ;  in NEXTL macro on older PICs, since that macro uses the addlw
                                           ;  instruction.
                                           ;
                                           
                                           
                                           ;
                                           ;  Declare some variables used by the macro library.
                                           ;
                                           
                                           	variable	_forknt=0
                                           	variable	_nxtknt=0
                                           	variable	_rptknt=0
                                           	variable	_alwknt=0
                                           	variable	_untknt=0
                                           	variable	_seltot=0
                                           	variable	_selknt=0
                                           	variable	_castot=0
                                           	variable	_casknt=0
                                           	variable	_waitk=0
                                           	variable	_pollk=0
                                           	variable	_pollt=0
                                           
                                           
                                           
                                           ;
                                           ;  Define the BEQ (branch-if-equal)
                                           ;
                                           ;  Syntax:
                                           ;		beq	label
                                           ;
                                           ;  The BEQ macro tests the current state of the Z-bit.  It
                                           ;  does not alter W or any registers.
                                           ;
                                           
                                           beq	macro	addr
00008c   b4d8     btfsc	0xd8, 0x2, 0       	btfsc	STATUS,Z
00008e   ef4c     goto	0x98                	goto	addr
000090   f000
                                           	endm
                                           
                                           
                                           ;
                                           ;  BNE (branch-if-not-equal)
                                           ;
                                           ;  Syntax:
                                           ;		bne	label
                                           ;
                                           ;  The BNE macro tests the current state of the Z-bit.  It
                                           ;  does not alter W or any registers.
                                           ;
                                           
                                           bne	macro	addr
                                           	btfss	STATUS,Z
                                           	goto	addr
                                           	endm
                                           
                                           
                                           ;
                                           ;  FOR (start of FOR-NEXT loop)
                                           ;
                                           ;  Syntax:
                                           ;		for	var,begl,endl
                                           ;
                                           ;  The FOR macro starts a FOR-NEXT loop.  The arguments are:
                                           ;  var is a RAM variable used as the loop index,
                                           ;  begl is a literal value used as the initial index value,
                                           ;  endl is a literal value used as the ending index value.
                                           ;
                                           ;  Control will run through the FOR-NEXT loop until the value
                                           ;  in var EQUALS the endl literal value; the value is tested
                                           ;  at the top of the loop.  At this point, control exits the
                                           ;  loop at the corresponding NEXT macro.
                                           ;
                                           ;  This macro destroys the contents of the W register.
                                           ;
                                           ;  You may terminate a FOR loop with NEXT, NEXTL, or NEXTF.
                                           ;
                                           
                                           for	macro	var,begl,endl
                                           	movlw	begl
                                           	movwf	var
                                           _for#v(_forknt)
                                           	movlw	endl
                                           	subwf	var,w
                                           ;	movf	var,w
                                           ;	sublw	endl
                                           	beq	_next#v(_forknt)
                                           _forknt	set	_forknt+1
                                           _nxtknt	set	_forknt
                                           	endm
                                           
                                           
                                           ;
                                           ;  FORF (start of FORF-NEXT loop)
                                           ;
                                           ;  Syntax:
                                           ;		forf	var,begl,endf
                                           ;
                                           ;  The FORF macro starts a FORF-NEXT loop.  The arguments are:
                                           ;  var is a RAM variable used as the loop index,
                                           ;  begl is a literal value used as the initial index value,
                                           ;  endf is a flag or RAM variable used as the ending index
                                           ;  value.
                                           ;
                                           ;  Control will run through the FORF-NEXT loop until the value
                                           ;  in var EQUALS the endf variable value; the value is tested
                                           ;  at the top of the loop.  At this point, control exits the
                                           ;  loop at the corresponding NEXT macro.
                                           ;
                                           ;  This macro destroys the contents of the W register.
                                           ;
                                           ;  You may terminate a FORF loop with NEXT, NEXTL, or NEXTF.
                                           ;
                                           
                                           forf	macro	var,begl,endf
                                           	movlw	begl
                                           	movwf	var
                                           _for#v(_forknt)
                                           	movf	var,w
                                           	subwf	endf
                                           	beq	_next#v(_forknt)
                                           _forknt	set	_forknt+1
                                           _nxtknt	set	_forknt
                                           	endm
                                           
                                           
                                           ;
                                           ;  NEXT (end of a FOR-NEXT loop)
                                           ;
                                           ;  Syntax:
                                           ;		next	var
                                           ;
                                           ;  The NEXT macro terminates a FOR-NEXT loop.  The 
                                           ;  argument is:
                                           ;  var is a RAM variable that is the index of the FOR-NEXT loop.
                                           ;
                                           ;  Control will increment the value in var, then go back to
                                           ;  the top of the FOR-NEXT loop for testing.  Note that the var
                                           ;  argument for the NEXT macro must match the var argument for
                                           ;  the corresponding FOR macro.  The macro library does not perform
                                           ;  this check for you; you have to get it right yourself!
                                           ;
                                           ;  This macro alters the contents of the W register and the index
                                           ;  variable var.
                                           ;
                                           ;  You may use NEXT to terminate a FOR-NEXT, FORF-NEXT, or
                                           ;  FORL-NEXT loop.
                                           ;
                                           
                                           next	macro	var
                                           _nxtknt	set	_nxtknt-1
                                           	incf	var,f
                                           	goto	_for#v(_nxtknt)
                                           _next#v(_nxtknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  NEXTL (end of a FOR-NEXTL loop)
                                           ;
                                           ;  Syntax:
                                           ;		nextl	var,incl
                                           ;
                                           ;  The NEXTL macro terminates a FOR-NEXTL loop.  The 
                                           ;  arguments are:
                                           ;  var is a RAM variable that is the index of the FOR-NEXTL loop,
                                           ;  incl is a literal value used to modify the index.
                                           ;
                                           ;  Control will add the literal incl to the value in var, then
                                           ;  go back to the top of the FOR-NEXTL loop for testing.  Note
                                           ;  that the var argument for the NEXTL macro must match the var
                                           ;  argument for the corresponding FOR macro.  The macro library
                                           ;  does not perform this check for you; you have to get it right
                                           ;  yourself!
                                           ;
                                           ;  This macro alters the contents of the W register and the index
                                           ;  variable var.
                                           ;
                                           ;  You may use NEXTL to terminate a FOR-NEXTL, FORF-NEXTL, or
                                           ;  FORL-NEXTL loop.
                                           ;
                                           ;  NOTE:  This macro uses the addlw instruction, which is not
                                           ;  supported on the older PICs, such as the 16c54.  Using this
                                           ;  macro in a source file for such a chip will generate assembler
                                           ;  errors.
                                           ;
                                           
                                           nextl	macro	var,incl
                                           _nxtknt	set	_nxtknt-1
                                           	movf	var,w
                                           	addlw	incl
                                           	movwf	var
                                           	goto	_for#v(_nxtknt)
                                           _next#v(_nxtknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  NEXTF (end of a FOR-NEXTF loop)
                                           ;
                                           ;  Syntax:
                                           ;		nextf	var,incf
                                           ;
                                           ;  The NEXTF macro terminates a FOR-NEXTF loop.  The 
                                           ;  arguments are:
                                           ;  var is a RAM variable that is the index of the FOR-NEXTL loop,
                                           ;  incf is a register whose value is used to modify the index.
                                           ;
                                           ;  Control will add the value in incf to the value in var, then
                                           ;  go back to the top of the FOR-NEXTF loop for testing.  Note
                                           ;  that the var argument for the NEXTF macro must match the var
                                           ;  argument for the corresponding FOR macro.  The macro library
                                           ;  does not perform this check for you; you have to get it right
                                           ;  yourself!
                                           ;
                                           ;  This macro alters the contents of the W register and the index
                                           ;  variable var.
                                           ;
                                           ;  You may use NEXTF to terminate a FOR-NEXTF, FORF-NEXTF, or
                                           ;  FORL-NEXTF loop.
                                           ;
                                           
                                           nextf	macro	var,incf
                                           _nxtknt	set	_nxtknt-1
                                           	movf	var,w
                                           	addwf	incf,f
                                           	goto	_for#v(_nxtknt)
                                           _next#v(_nxtknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  REPEAT (start of a REPEAT-ALWAYS or REPEAT-UNTIL loop)
                                           ;
                                           ;  Syntax:
                                           ;		repeat
                                           ;
                                           ;  The REPEAT macro marks the start of a REPEAT-ALWAYS or
                                           ;  REPEAT-UNTILEQ or REPEAT-UNTILNE loop.  Control will always
                                           ;  return to the start of the REPEAT macro if the loop is
                                           ;  terminated with an ALWAYS macro.  Control will conditionally
                                           ;  return to the start of the REPEAT macro if the loop is
                                           ;  terminated with an UNTILEQ or UNTILNE macro.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           repeat	macro
                                           _rpt#v(_rptknt)
                                           _rptknt	set	_rptknt+1
                                           _alwknt	set	_rptknt
                                           _untknt	set	_rptknt
                                           	endm
                                           
                                           
                                           ;
                                           ;  ALWAYS (returns to corresponding REPEAT macro)
                                           ;
                                           ;  Syntax:
                                           ;		always
                                           ;
                                           ;  The ALWAYS macro marks the end of a REPEAT-ALWAYS loop.
                                           ;  Control is automatically passed back to the corresponding
                                           ;  REPEAT macro.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           always	macro
                                           _alwknt	set	_alwknt-1
                                           	goto	_rpt#v(_alwknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  UNTILEQ (conditionally returns to corresponding REPEAT macro)
                                           ;
                                           ;  Syntax:
                                           ;		untileq
                                           ;
                                           ;  The UNTILEQ macro marks the end of a REPEAT-UNTILEQ loop.
                                           ;  Control is passed back to the corresponding REPEAT macro only
                                           ;  if the Z-bit is cleared at the time the UNTILEQ macro is
                                           ;  processed.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           untileq	macro
                                           _untknt	set	_untknt-1
                                           	bne	_rpt#v(_untknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  UNTILNE (conditionally returns to corresponding REPEAT macro)
                                           ;
                                           ;  Syntax:
                                           ;		untilne
                                           ;
                                           ;  The UNTILEQ macro marks the end of a REPEAT-UNTILNE loop.
                                           ;  Control is passed back to the corresponding REPEAT macro only
                                           ;  if the Z-bit is set at the time the UNTILNE macro is processed.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           untilne	macro
                                           _untknt	set	_untknt-1
                                           	beq	_rpt#v(_untknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  SELECT (declares start of SELECT-ENDSELECT structure)
                                           ;
                                           ;  Syntax:
                                           ;		select
                                           ;
                                           ;  The SELECT macro marks the beginning of a SELECT-ENDSELECT
                                           ;  structure.  A typical SELECT-ENDSELECT structure looks like this:
                                           ;
                                           ;	select			; start of SELECT block
                                           ;	case	5		; if W = 5...
                                           ;	  .			; do something
                                           ;	endcase			; end of W = 5 clause
                                           ;	casef	foo		; if W = foo
                                           ;	  .			; do something else
                                           ;	endcase			; end of W = foo clause
                                           ;	  .			; default action (all cases fail)
                                           ;	endselect		; end of SELECT block
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           select	macro variable
000088   5000     movf	0, 0, 0             	movf variable, w
                                           _seltot	set	_seltot+1
                                           _selknt	set	_seltot
                                           	endm
                                           
                                           
                                           ;
                                           ;  ENDSELECT (declares end of SELECT-ENDSELECT structure)
                                           ;
                                           ;  Syntax:
                                           ;		endselect
                                           ;
                                           ;  The ENDSELECT macro marks the end of a SELECT-ENDSELECT
                                           ;  structure.  You must terminate each SELECT macro with
                                           ;  a matching ENDSELECT macro or MPASM will report errors.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           endselect	macro
                                           sel#v(_selknt)
                                           _selknt	set	_selknt-1
                                           	endm
                                           
                                           
                                           ;
                                           ;  CASE (declares start of a CASE-ENDCASE structure)
                                           ;
                                           ;  Syntax:
                                           ;		case	lit
                                           ;
                                           ;  where lit is a literal value used as the CASE selector.
                                           ;
                                           ;  When the CASE macro is executed, the value in W is compared
                                           ;  with the literal value lit.  If W equals lit, code following
                                           ;  the CASE macro is executed.  If W does not equal lit, control
                                           ;  passes to the code following the corresponding ENDCASE macro.
                                           ;
                                           ;  W is preserved in the CASE macro.
                                           ;
                                           
                                           case	macro	lit
                                           _castot set	_castot+1
                                           _casknt	set	_castot
00008a   0a00     xorlw	0                  	xorlw	lit
                                           	beq	cas#v(_casknt)
000092   0a00     xorlw	0                  	xorlw	lit
000094   ef54     goto	0xa8                	goto	ecas#v(_casknt)
000096   f000
                                           cas#v(_casknt)
000098   0a00     xorlw	0                  	xorlw	lit
                                           	endm
                                           
                                           
                                           ;
                                           ;  CASEF (declares start of a CASEF-ENDCASE structure)
                                           ;
                                           ;  Syntax:
                                           ;		casef	var
                                           ;
                                           ;  where var is a register or variable used as the CASEF selector.
                                           ;
                                           ;  When the CASEF macro is executed, the value in W is compared
                                           ;  with the value in var.  If W equals var, code following
                                           ;  the CASEF macro is executed.  If W does not equal var, control
                                           ;  passes to the code following the corresponding ENDCASE macro.
                                           ;
                                           ;  W is preserved in the CASEF macro.
                                           ;
                                           
                                           casef	macro	var
                                           _castot set	_castot+1
                                           _casknt	set	_castot
                                           	xorwf	var,w
                                           	beq	cas#v(_casknt)
                                           	xorwf	var,w
                                           	goto	ecas#v(_casknt)
                                           cas#v(_casknt)
                                           	xorwf	var,w
                                           	endm
                                           
                                           
                                           ;
                                           ;  ENDCASE (declares end of a CASE-ENDCASE or CASEF-ENDCASE structure)
                                           ;
                                           ;  Syntax:
                                           ;		endcase
                                           ;
                                           ;  The ENDCASE macro marks the end of a CASE-ENDCASE or CASEF-ENDCASE
                                           ;  structure.  This macro serves as a jump address for the corresponding
                                           ;  CASE or CASEF macro.
                                           ;
                                           ;  You must have an ENDCASE macro for each CASE or CASEF macro.  If
                                           ;  not, MPASM will report errors when it assembles your code.
                                           ;
                                           ;  This macro preserves the W register.
                                           ;
                                           
                                           endcase	macro
0000a4   ef9e     goto	0x13c               	goto	sel#v(_selknt)
0000a6   f000
                                           ecas#v(_casknt)
                                           _casknt	set	_casknt-1
                                           	endm
                                           
                                           
                                           ;
                                           ;  WAITWHILE (declares a high-speed WAIT-WHILE loop)
                                           ;
                                           ;  Syntax:
                                           ;
                                           ;  		waitwhile	addr,andl,xorl
                                           ;
                                           ;  The WAITWHILE macro creates a tight loop that reads the byte
                                           ;  in address addr, ANDs it with the literal andl, then XORs the
                                           ;  result with the literal xorl.  If the result is TRUE (non-zero),
                                           ;  the loop repeats.  If the result is FALSE (zero), control exits
                                           ;  the macro.
                                           ;
                                           ;  This macro destroys the W register.  It does not modify addr.
                                           ;
                                           
                                           waitwhile	macro	addr,andl,xorl
                                           waitw#v(_waitk)
                                           	movf	addr,w
                                           	andlw	andl
                                           	if	xorl != 0
                                           	xorlw	xorl
                                           	endif
                                           	bne	waitw#v(_waitk)
                                           _waitk	set	_waitk+1
                                           	endm
                                           
                                           
                                           ;
                                           ;  WAITUNTIL (declares a high-speed WAIT-UNTIL loop)
                                           ;
                                           ;  Syntax:
                                           ;
                                           ;  		waituntil	addr,andl,xorl
                                           ;
                                           ;  The WAITUNTIL macro creates a tight loop that reads the byte
                                           ;  in address addr, ANDs it with the literal andl, then XORs the
                                           ;  result with the literal xorl.  If the result is TRUE (non-zero),
                                           ;  control exits the macro.  If the result is FALSE (zero),
                                           ;  the loop repeats.
                                           ;
                                           ;  This macro destroys the W register.  It does not modify addr.
                                           ;
                                           
                                           
                                           waituntil	macro	addr,andl,xorl
                                           waitw#v(_waitk)
                                           	movf	addr,w
                                           	andlw	andl
                                           	if	xorl != 0
                                           	xorlw	xorl
                                           	endif
                                           	beq	waitw#v(_waitk)
                                           _waitk	set	_waitk+1
                                           	endm
                                           
                                           
                                           ;
                                           ;  POLL (starts a POLL-ENDPOLL structure)
                                           ;
                                           ;  Syntax:
                                           ;
                                           ;  		poll	addr,andl,xorl
                                           ;
                                           ;  The POLL macro reads the byte in address addr, ANDs it with
                                           ;  the literal andl, then XORs the result with the literal xorl.
                                           ;  If the result is TRUE (non-zero), control passes to the code
                                           ;  immediately following the macro.  If the result is FALSE
                                           ;  (zero), control jumps to the corresponding ENDPOLL macro.
                                           ;
                                           ;  For example, the following POLL command will test the address
                                           ;  SPORT for bit 3 high:
                                           ;
                                           ;	poll	SPORT,8,0		test bit 3
                                           ;	nop				do this if bit 3 is high
                                           ;	endpoll
                                           ;
                                           ;  The following POLL command will test the address SPORT for
                                           ;  bit 3 high while either bits 2 or 1 are low:
                                           ;
                                           ;	poll	SPORT,0x0e,0x06		test bits 1-3
                                           ;	nop				do if 3 is high, 1 or 2 is low
                                           ;	endpoll
                                           ;
                                           ;  This macro destroys the W register.  It does not modify addr.
                                           ;
                                           
                                           
                                           poll	macro	addr,andl,xorl
                                           _pollt	set	_pollt+1
                                           _pollk	set	_pollt
                                           	movf	addr,w
                                           	andlw	andl
                                           	xorlw	xorl
                                           	beq	poll#v(_pollk)
                                           	endm
                                           
                                           
                                           ;
                                           ;  ENDPOLL (marks end of a POLL-ENDPOLL structure)
                                           ;
                                           ;  The ENDPOLL macro terminates a POLL-ENDPOLL structure.
                                           ;  Control reaches this macro if the associated POLL macro
                                           ;  fails.
                                           ;
                                           
                                           endpoll	macro
                                           poll#v(_pollk)
                                           _pollk	set	_pollk-1
                                           endm
                                           
                                           
                                           PointFSR0To macro varname
0000e6   0e00     movlw	0                  	movlw	high varname
0000e8   6eea     movwf	0xea, 0            	movwf	FSR0H
0000ea   0e02     movlw	0x2                	movlw	low varname
0000ec   6ee9     movwf	0xe9, 0            	movwf	FSR0L
                                           endm
                                           
                                           PointFSR1To macro varname
                                           	movlw	high varname
                                           	movwf	FSR1H
                                           	movlw	low varname
                                           	movwf	FSR1L
                                           endm
                                           
                                           PointFSR2To macro varname
                                           	movlw	high varname
                                           	movwf	FSR2H
                                           	movlw	low varname
                                           	movwf	FSR2L
                                           endm
                                           
                                           gtifz	macro point
00009e   a4d8     btfss	0xd8, 0x2, 0       	btfss STATUS,Z
0000a0   efaf     goto	0x15e               	goto  point
0000a2   f000
                                           endm
                                           #include <lcd18.inc>
                                           	extern	InitLCD,WrtLCD,ClrLCD,ClkLCD,PosLCD
                                           
                                           
                                           ;;;;;;Configuration Bits;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                           
                                           		CONFIG OSC=HS, FCMEN=OFF, IESO=OFF
                                           		CONFIG PWRT = OFF, BOREN = SBORDIS, BORV = 3
                                           		CONFIG WDT = OFF, WDTPS = 32768
                                           		CONFIG MCLRE = ON, LPT1OSC = OFF, PBADEN = OFF, CCP2MX = PORTC
                                           		CONFIG STVREN = ON, LVP = OFF, XINST = OFF
                                           		CONFIG DEBUG = OFF
                                           		CONFIG CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF
                                           		CONFIG CPB = OFF, CPD = OFF
                                           		CONFIG WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
                                           		CONFIG WRTB = OFF, WRTC = OFF, WRTD = OFF
                                           		CONFIG EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
                                           		CONFIG EBTRB = OFF
                                           
                                           	udata_acs
                                           state	res 1
                                           key_pressed res 1
                                           
                                           offset_bcd res 2
                                           interval_bcd res 2
                                           
                                           param_offset res 2		;offset in cm, up to 300, therefore 2 bytes
                                           param_interval res 2
                                           
                                           tmp1	res 1			;temporary storage for calculations
                                           
                                           ;;;;;;Vectors;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                           	org		0x0000
                                           	
                                           	
000000   ef13     goto	0x26                	goto	Init
000002   f000
                                           	
                                           	org		0x08				;high priority ISR
000008   ef0f     goto	0x1e                	goto IHR
00000a   f000
                                           
                                           	org		0x18				;low priority ISR
000018   ef0f     goto	0x1e                	goto IHR
00001a   f000
00001c   0010     retfie	0                 	retfie
                                           
                                           	code
                                           
                                           IHR
                                           	;; if it was a key input, go to the menu handling thing.
00001e   b281     btfsc	0x81, 0x1, 0       	btfsc	PORTB,1		;
000020   ef40     goto	0x80                	goto	menu_handler
000022   f000
                                           	
                                           	
                                           	
000024   0010     retfie	0                 	retfie
                                           	
                                           Init
000026   6af2     clrf	0xf2, 0             	clrf	INTCON		; no interrupts
000028   6a92     clrf	0x92, 0             	clrf	TRISA		; PORTA is output
00002a   0ef2     movlw	0xf2               	movlw	b'11110010'	; Keypad inputs on Port B
00002c   6e93     movwf	0x93, 0            	movwf	TRISB
00002e   6a94     clrf	0x94, 0             	clrf	TRISC
000030   6a95     clrf	0x95, 0             	clrf	TRISD
                                           
000032   6a89     clrf	0x89, 0             	clrf	LATA
000034   6a8a     clrf	0x8a, 0             	clrf	LATB
000036   6a8b     clrf	0x8b, 0             	clrf	LATC
000038   6a8c     clrf	0x8c, 0             	clrf	LATD
                                           
00003a   0eaa     movlw	0xaa               movlw	b'10101010'
00003c   6e8b     movwf	0x8b, 0            	movwf	LATC
                                           	
00003e   eca3     call	0x346, 0            	call	InitLCD		; Initializes the LCD
000040   f001
000042   86f0     bsf	0xf0, 0x3, 0         	bsf	INTCON3, INT1IE
000044   8af1     bsf	0xf1, 0x5, 0         	bsf	INTCON2, INTEDG1 ; enable RB1 interrupts
000046   8ef2     bsf	0xf2, 0x7, 0         	bsf	INTCON, GIE
000048   0e00     movlw	0                  	movlw	0
00004a   6e00     movwf	0, 0               	movwf	state
00004c   ecb9     call	0x172, 0            	call	menu_drawscreen
00004e   f000
000050   efa0     goto	0x340               	goto	Mainline
000052   f001
                                           	
                                           	;; ****************************************
                                           	;; KPHexToInt converts key_pressed into the corresponding number
                                           	;; ****************************************
                                           KPHexToInt
000054   0e00     movlw	0                  	movlw	upper KeyTbl
000056   6ef8     movwf	0xf8, 0            	movwf	TBLPTRU
000058   0e00     movlw	0                  	movlw	high KeyTbl
00005a   6ef7     movwf	0xf7, 0            	movwf	TBLPTRH
00005c   0e6e     movlw	0x6e               	movlw	low KeyTbl
00005e   2401     addwf	0x1, 0, 0          	addwf	key_pressed, W	;add the key offset to the lower end of the table
000060   6ef6     movwf	0xf6, 0            	movwf	TBLPTRL
000062   0e00     movlw	0                  	movlw	0
000064   22f7     addwfc	0xf7, 0x1, 0      	addwfc	TBLPTRH, F	;let the carry ripple up if we went too far
000066   22f8     addwfc	0xf8, 0x1, 0      	addwfc	TBLPTRU, F
                                           
000068   0008     tblrd	*                  	tblrd	*		;read that thing into the latch
                                           	
00006a   50f5     movf	0xf5, 0, 0          	movf	TABLAT, W	;put it into W
00006c   6e01     movwf	0x1, 0             	movwf	key_pressed
                                           	
00006e   0201     mulwf	0x1, 0             KeyTbl	db 1, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9, 0, 0, 0, 0, 0 ;the list of values
000070   0003     sleep                    
000072   0504     decf	0x4, 0, 0x1         
000074   0006     pop                      
000076   0807     sublw	0x7                
000078   0009     tblrd	*+                 
00007a   0000     nop                      
00007c   0000     nop                      
00007e   0012     return	0                 	return
                                           
                                           
                                           	;; ****************************************
                                           	;; Menu Handler: Takes care of navigation through the menu
                                           	;; ****************************************
                                           menu_handler
000080   3881     swapf	0x81, 0, 0         	swapf	PORTB,W		;read PortB<7:4> into W<3:0>
000082   0b0f     andlw	0xf                	andlw	0x0F		;mask the lower nibble
000084   44e8     rlncf	0xe8, 0, 0         	rlncf	WREG, W		;program memory counts up by two
000086   6e01     movwf	0x1, 0             	movwf	key_pressed
                                           
                                           	select state
                                           	case 0			;Welcome screen
00009a   5001     movf	0x1, 0, 0           		movf	key_pressed, w
00009c   0a0f     xorlw	0xf                		xorlw	15	;D:Next
                                           		gtifz	menu_next
                                           
                                           	endcase
                                           	case 1			;Load Prompt
0000b8   5001     movf	0x1, 0, 0           		movf	key_pressed, w
0000ba   0a0c     xorlw	0xc                		xorlw	12	;*:Back
                                           		gtifz	menu_back	
0000c2   0a0f     xorlw	0xf                		xorlw	3 ^ 12	;A:Load
                                           		gtifz	menu_next
0000ca   0a03     xorlw	0x3                		xorlw	15 ^ 12	;D:Next
                                           		gtifz	menu_skip
                                           
                                           	endcase
                                           	case 2			;Offset Prompt
                                           		PointFSR0To	offset_bcd ;append to offset variable
0000ee   5001     movf	0x1, 0, 0           		movf	key_pressed, w
0000f0   0a0c     xorlw	0xc                		xorlw	12	;*:Back
                                           		gtifz	menu_back	
0000f8   0a07     xorlw	0x7                		xorlw	11 ^ 12	;C:Delete
                                           		gtifz	parameter_delete
000100   0a04     xorlw	0x4                		xorlw	15 ^ 11	;D:Next
                                           		gtifz	menu_skip	
                                           
                                           	;; test for other keys AB#:
000108   0a0c     xorlw	0xc                		xorlw	3 ^ 15
                                           		gtifz	Mainline
000110   0a04     xorlw	0x4                		xorlw	7 ^ 3
                                           		gtifz	Mainline
000118   0a09     xorlw	0x9                		xorlw	14 ^ 7
                                           		gtifz	Mainline
                                           
                                           	;; otherwise, it's a number key. append.
000120   efa1     goto	0x142               		goto	parameter_append
000122   f000
                                           	
                                           	endcase
                                           	case 3			;Interval Prompt
                                           
                                           	endcase
                                           	endselect
                                           	
00013c   5281     movf	0x81, 0x1, 0        	movf	PORTB, f
                                           
00013e   efa0     goto	0x340               	goto	Mainline
000140   f001
                                           
                                           
                                           
                                           	;; ****************************************
                                           	;; Adds an offset or interval character and updates the display
                                           	;; ****************************************
                                           parameter_append
000142   ec2a     call	0x54, 0             	call	KPHexToInt
000144   f000
                                           	;; rotate left by 4 bits
000146   36ef     rlcf	0xef, 0x1, 0        	rlcf	INDF0, f, 4
000148   0b0f     andlw	0xf                	andlw	b'00001111'
00014a   16ef     andwf	0xef, 0x1, 0       	andwf	INDF0
00014c   6eef     movwf	0xef, 0            	movwf	INDF0
00014e   efa0     goto	0x340               	goto 	Mainline
000150   f001
000152   0012     return	0                 	return
                                           
                                           	;; ****************************************
                                           	;; Deletes an offset or interval character and updates the display
                                           	;; ****************************************
                                           parameter_delete
000154   42ef     rrncf	0xef, 0x1, 0       	rrncf	INDF0, f, 4
000156   0e08     movlw	0x8                	movlw	8
000158   32eb     rrcf	0xeb, 0x1, 0        	rrcf	PLUSW0,f, 4	;goto the upper byte and shift it down by four as well
00015a   efa0     goto	0x340               	goto Mainline		;just in case.
00015c   f001
                                           
                                           
                                           
                                           	;; ****************************************
                                           	;; Increases the state counter and draws the screen
                                           	;; ****************************************
                                           menu_next
00015e   2a00     incf	0, 0x1, 0           	incf	state
000160   efb9     goto	0x172               	goto	menu_drawscreen
000162   f000
                                           
                                           	;; ****************************************
                                           	;; Decreases the state counter and draws the screen
                                           	;; ****************************************
                                           menu_back
000164   0600     decf	0, 0x1, 0           	decf	state
000166   efb9     goto	0x172               	goto	menu_drawscreen
000168   f000
                                           
                                           	;; ****************************************
                                           	;; Increases the state counter by two and draws the screen
                                           	;; ****************************************
                                           menu_skip
00016a   2a00     incf	0, 0x1, 0           	incf	state
00016c   2a00     incf	0, 0x1, 0           	incf	state
00016e   efb9     goto	0x172               	goto	menu_drawscreen
000170   f000
                                           
                                           	;; ****************************************
                                           	;; Draws on the display whatever the current state calls for.
                                           	;; ****************************************
                                           menu_drawscreen
                                           	;;  first, load the tablepointer to the tables and write the first and
                                           	;;  second line to the display.
                                           	;;  then, take care of inserting the current variable values.
000172   ecda     call	0x3b4, 0            	call	ClrLCD
000174   f001
000176   0e00     movlw	0                  	movlw	upper LCDTbl_1
000178   6ef8     movwf	0xf8, 0            	movwf	TBLPTRU
00017a   0e02     movlw	0x2                	movlw	high LCDTbl_1
00017c   6ef7     movwf	0xf7, 0            	movwf	TBLPTRH
                                           	
00017e   c000     movff	0, 0xa             	movff	state, tmp1
000180   f00a
000182   0e10     movlw	0x10               	movlw	16
000184   020a     mulwf	0xa, 0             	mulwf	tmp1		;now tmp1 = state * 16
000186   6e0a     movwf	0xa, 0             	movwf	tmp1
                                           
000188   0e00     movlw	0                  	movlw	low LCDTbl_1
00018a   240a     addwf	0xa, 0, 0          	addwf	tmp1, W		;add the key offset*16 to the lower end of the table
                                           	
00018c   6ef6     movwf	0xf6, 0            	movwf	TBLPTRL
00018e   0e00     movlw	0                  	movlw	0
000190   22f7     addwfc	0xf7, 0x1, 0      	addwfc	TBLPTRH, F	;let the carry ripple up if we went too far
000192   22f8     addwfc	0xf8, 0x1, 0      	addwfc	TBLPTRU, F
000194   0008     tblrd	*                  	tblrd	*		;read that thing into the latch
000196   50f5     movf	0xf5, 0, 0          	movf	TABLAT, W	;put it into W
                                           NextChar_1
000198   eccf     call	0x39e, 0            	call	WrtLCD		;loop through the table entry until 0 is hit
00019a   f001
00019c   000b     tblrd	+*                 	tblrd	+*
00019e   50f5     movf	0xf5, 0, 0          	movf	TABLAT,W
0001a0   e1fb     bnz	0x198                	bnz	NextChar_1
                                           
                                           	;; write second line
0001a2   0e14     movlw	0x14               	movlw	.20		;go to position 20
0001a4   ecea     call	0x3d4, 0            	call	PosLCD		;MIGHT NOT WORK correctly -- experimental
0001a6   f001
0001a8   0e00     movlw	0                  	movlw	upper LCDTbl_2
0001aa   6ef8     movwf	0xf8, 0            	movwf	TBLPTRU
0001ac   0e02     movlw	0x2                	movlw	high LCDTbl_2
0001ae   6ef7     movwf	0xf7, 0            	movwf	TBLPTRH
0001b0   0ea2     movlw	0xa2               	movlw	low LCDTbl_2
0001b2   2400     addwf	0, 0, 0            	addwf	state, W	;add the key offset to the lower end of the table
0001b4   6ef6     movwf	0xf6, 0            	movwf	TBLPTRL
0001b6   0e00     movlw	0                  	movlw	0
0001b8   22f7     addwfc	0xf7, 0x1, 0      	addwfc	TBLPTRH, F	;let the carry ripple up if we went too far
0001ba   22f8     addwfc	0xf8, 0x1, 0      	addwfc	TBLPTRU, F
0001bc   0008     tblrd	*                  	tblrd	*		;read that thing into the latch
0001be   50f5     movf	0xf5, 0, 0          	movf	TABLAT, W	;put it into W
                                           NextChar_2
0001c0   eccf     call	0x39e, 0            	call	WrtLCD		;loop through the table entry until 0 is hit
0001c2   f001
0001c4   000b     tblrd	+*                 	tblrd	+*
0001c6   50f5     movf	0xf5, 0, 0          	movf	TABLAT,W
0001c8   e1fb     bnz	0x1c0                	bnz	NextChar_2	
                                           
                                           	
                                           	
                                           	;; Congrats! By now, the standard content for each state should be written.
                                           	
                                           	select state
                                           	case 	3		;add the offset value
0001dc   0e07     movlw	0x7                	movlw 	.7
0001de   ecea     call	0x3d4, 0            	call	PosLCD
0001e0   f001
                                           	;; write offset
                                           	endcase
                                           	case 	4			;add the interval value
0001f6   0e09     movlw	0x9                	movlw	.9
0001f8   ecea     call	0x3d4, 0            	call	PosLCD
0001fa   f001
                                           	;; write interval
                                           	endcase
                                           	endselect
                                           
                                           LCDTbl_1
000200   6557     cpfsgt	0x57, 0x1         	db "Welcome        ",0,"         Load:A",0,"Ins Cone!   Up:A",0,"Offset:_       ",0,"Interval:_     ",0,"Ready!         ",0,"Deploying ...  ",0,"Success! Stats:A",0,"   cm( ) Next:A",0,"Store?    Yes:A",0
000202   636c     cpfseq	0x6c, 0x1         
000204   6d6f     negf	0x6f, 0x1           
000206   2065     addwfc	0x65, 0, 0        
000208   2020     addwfc	0x20, 0, 0        
00020a   2020     addwfc	0x20, 0, 0        
00020c   2020     addwfc	0x20, 0, 0        
00020e   0020     dw	0x20  ;unknown opcode 
000210   2020     addwfc	0x20, 0, 0        
000212   2020     addwfc	0x20, 0, 0        
000214   2020     addwfc	0x20, 0, 0        
000216   2020     addwfc	0x20, 0, 0        
000218   4c20     dcfsnz	0x20, 0, 0        
00021a   616f     cpfslt	0x6f, 0x1         
00021c   3a64     swapf	0x64, 0x1, 0       
00021e   0041     dw	0x41  ;unknown opcode 
000220   6e49     movwf	0x49, 0            
000222   2073     addwfc	0x73, 0, 0        
000224   6f43     movwf	0x43, 0x1          
000226   656e     cpfsgt	0x6e, 0x1         
000228   2021     addwfc	0x21, 0, 0        
00022a   2020     addwfc	0x20, 0, 0        
00022c   7055     btg	0x55, 0, 0           
00022e   413a     rrncf	0x3a, 0, 0x1       
000230   4f00     dcfsnz	0, 0x1, 0x1       
000232   6666     tstfsz	0x66, 0           
000234   6573     cpfsgt	0x73, 0x1         
000236   3a74     swapf	0x74, 0x1, 0       
000238   205f     addwfc	0x5f, 0, 0        
00023a   2020     addwfc	0x20, 0, 0        
00023c   2020     addwfc	0x20, 0, 0        
00023e   2020     addwfc	0x20, 0, 0        
000240   4900     infsnz	0, 0, 0x1         
000242   746e     btg	0x6e, 0x2, 0         
000244   7265     btg	0x65, 0x1, 0         
000246   6176     cpfslt	0x76, 0x1         
000248   3a6c     swapf	0x6c, 0x1, 0       
00024a   205f     addwfc	0x5f, 0, 0        
00024c   2020     addwfc	0x20, 0, 0        
00024e   2020     addwfc	0x20, 0, 0        
000250   5200     movf	0, 0x1, 0           
000252   6165     cpfslt	0x65, 0x1         
000254   7964     btg	0x64, 0x4, 0x1       
000256   2021     addwfc	0x21, 0, 0        
000258   2020     addwfc	0x20, 0, 0        
00025a   2020     addwfc	0x20, 0, 0        
00025c   2020     addwfc	0x20, 0, 0        
00025e   2020     addwfc	0x20, 0, 0        
000260   4400     rlncf	0, 0, 0            
000262   7065     btg	0x65, 0, 0           
000264   6f6c     movwf	0x6c, 0x1          
000266   6979     setf	0x79, 0x1           
000268   676e     tstfsz	0x6e, 0x1         
00026a   2e20     decfsz	0x20, 0x1, 0      
00026c   2e2e     decfsz	0x2e, 0x1, 0      
00026e   2020     addwfc	0x20, 0, 0        
000270   5300     movf	0, 0x1, 0x1         
000272   6375     cpfseq	0x75, 0x1         
000274   6563     cpfsgt	0x63, 0x1         
000276   7373     btg	0x73, 0x1, 0x1       
000278   2021     addwfc	0x21, 0, 0        
00027a   7453     btg	0x53, 0x2, 0         
00027c   7461     btg	0x61, 0x2, 0         
00027e   3a73     swapf	0x73, 0x1, 0       
000280   0041     dw	0x41  ;unknown opcode 
000282   2020     addwfc	0x20, 0, 0        
000284   6320     cpfseq	0x20, 0x1         
000286   286d     incf	0x6d, 0, 0          
000288   2920     incf	0x20, 0, 0x1        
00028a   4e20     dcfsnz	0x20, 0x1, 0      
00028c   7865     btg	0x65, 0x4, 0         
00028e   3a74     swapf	0x74, 0x1, 0       
000290   0041     dw	0x41  ;unknown opcode 
000292   7453     btg	0x53, 0x2, 0         
000294   726f     btg	0x6f, 0x1, 0         
000296   3f65     incfsz	0x65, 0x1, 0x1    
000298   2020     addwfc	0x20, 0, 0        
00029a   2020     addwfc	0x20, 0, 0        
00029c   6559     cpfsgt	0x59, 0x1         
00029e   3a73     swapf	0x73, 0x1, 0       
0002a0   0041     dw	0x41  ;unknown opcode 
                                           LCDTbl_2
0002a2   2020     addwfc	0x20, 0, 0        	db "         Start:D",0,"*:Back    Next:D",0,"*:Back    Next:D",0,"*:Back    Next:D",0,"*:Back    Next:D",0,"         Abort:C",0,"*:Back          ",0,"*:Back TDist:   ",0,"*:Back      No:B",0
0002a4   2020     addwfc	0x20, 0, 0        
0002a6   2020     addwfc	0x20, 0, 0        
0002a8   2020     addwfc	0x20, 0, 0        
0002aa   5320     movf	0x20, 0x1, 0x1      
0002ac   6174     cpfslt	0x74, 0x1         
0002ae   7472     btg	0x72, 0x2, 0         
0002b0   443a     rlncf	0x3a, 0, 0         
0002b2   2a00     incf	0, 0x1, 0           
0002b4   423a     rrncf	0x3a, 0x1, 0       
0002b6   6361     cpfseq	0x61, 0x1         
0002b8   206b     addwfc	0x6b, 0, 0        
0002ba   2020     addwfc	0x20, 0, 0        
0002bc   4e20     dcfsnz	0x20, 0x1, 0      
0002be   7865     btg	0x65, 0x4, 0         
0002c0   3a74     swapf	0x74, 0x1, 0       
0002c2   0044     dw	0x44  ;unknown opcode 
0002c4   3a2a     swapf	0x2a, 0x1, 0       
0002c6   6142     cpfslt	0x42, 0x1         
0002c8   6b63     clrf	0x63, 0x1           
0002ca   2020     addwfc	0x20, 0, 0        
0002cc   2020     addwfc	0x20, 0, 0        
0002ce   654e     cpfsgt	0x4e, 0x1         
0002d0   7478     btg	0x78, 0x2, 0         
0002d2   443a     rlncf	0x3a, 0, 0         
0002d4   2a00     incf	0, 0x1, 0           
0002d6   423a     rrncf	0x3a, 0x1, 0       
0002d8   6361     cpfseq	0x61, 0x1         
0002da   206b     addwfc	0x6b, 0, 0        
0002dc   2020     addwfc	0x20, 0, 0        
0002de   4e20     dcfsnz	0x20, 0x1, 0      
0002e0   7865     btg	0x65, 0x4, 0         
0002e2   3a74     swapf	0x74, 0x1, 0       
0002e4   0044     dw	0x44  ;unknown opcode 
0002e6   3a2a     swapf	0x2a, 0x1, 0       
0002e8   6142     cpfslt	0x42, 0x1         
0002ea   6b63     clrf	0x63, 0x1           
0002ec   2020     addwfc	0x20, 0, 0        
0002ee   2020     addwfc	0x20, 0, 0        
0002f0   654e     cpfsgt	0x4e, 0x1         
0002f2   7478     btg	0x78, 0x2, 0         
0002f4   443a     rlncf	0x3a, 0, 0         
0002f6   2000     addwfc	0, 0, 0           
0002f8   2020     addwfc	0x20, 0, 0        
0002fa   2020     addwfc	0x20, 0, 0        
0002fc   2020     addwfc	0x20, 0, 0        
0002fe   2020     addwfc	0x20, 0, 0        
000300   6241     cpfseq	0x41, 0           
000302   726f     btg	0x6f, 0x1, 0         
000304   3a74     swapf	0x74, 0x1, 0       
000306   0043     dw	0x43  ;unknown opcode 
000308   3a2a     swapf	0x2a, 0x1, 0       
00030a   6142     cpfslt	0x42, 0x1         
00030c   6b63     clrf	0x63, 0x1           
00030e   2020     addwfc	0x20, 0, 0        
000310   2020     addwfc	0x20, 0, 0        
000312   2020     addwfc	0x20, 0, 0        
000314   2020     addwfc	0x20, 0, 0        
000316   2020     addwfc	0x20, 0, 0        
000318   2a00     incf	0, 0x1, 0           
00031a   423a     rrncf	0x3a, 0x1, 0       
00031c   6361     cpfseq	0x61, 0x1         
00031e   206b     addwfc	0x6b, 0, 0        
000320   4454     rlncf	0x54, 0, 0         
000322   7369     btg	0x69, 0x1, 0x1       
000324   3a74     swapf	0x74, 0x1, 0       
000326   2020     addwfc	0x20, 0, 0        
000328   0020     dw	0x20  ;unknown opcode 
00032a   3a2a     swapf	0x2a, 0x1, 0       
00032c   6142     cpfslt	0x42, 0x1         
00032e   6b63     clrf	0x63, 0x1           
000330   2020     addwfc	0x20, 0, 0        
000332   2020     addwfc	0x20, 0, 0        
000334   2020     addwfc	0x20, 0, 0        
000336   6f4e     movwf	0x4e, 0x1          
000338   423a     rrncf	0x3a, 0x1, 0       
00033a   0000     nop                      
                                           
                                           	;; Congrats again! The display has been written! Go back and chill!
                                           
00033c   efa0     goto	0x340               	goto Mainline
00033e   f001
                                           	
                                           
                                           
                                           
                                           
                                           
                                           
                                           	
                                           Mainline
000340   90f0     bcf	0xf0, 0, 0           	bcf	INTCON3, INT1IF	;clear RB1 interrupt bit	
000342   efa1     goto	0x342               	goto	$
000344   f001
                                           end
                                           #include <p18f4620.inc>
                                                   LIST
                                           
                                           ;==========================================================================
                                           ;  MPASM PIC18F4620 processor include
                                           ; 
                                           ;  (c) Copyright 1999-2007 Microchip Technology, All rights reserved
                                           ;==========================================================================
                                           
                                                   NOLIST
                                           	
                                           	;Declare unbanked variables (at 0x70 and on)
                                           	udata
                                           lcd_tmp	res	1
                                           lcd_d1	res	1
                                           lcd_d2	res	1
                                           
                                           	;Declare constants for pin assignments (LCD on PORTD)
                                           RS 	equ 2
                                           E 	equ 3
                                           
                                           	;Helper macros
                                           WRT_LCD macro val
000378   0e28     movlw	0x28               	movlw   val
00037a   eccf     call	0x39e, 0            	call    WrtLCD
00037c   f001
                                           	endm
                                           	
                                           ;Delay: ~44us
                                           LCD_DELAY macro
0003c8   0e23     movlw	0x23               	movlw   0x23
0003ca   6f81     movwf	0x81, 0x1          	movwf   lcd_d1
0003cc   2f81     decfsz	0x81, 0x1, 0x1    	decfsz  lcd_d1,f
0003ce   efe6     goto	0x3cc               	goto    $-2
0003d0   f001
                                           	endm
                                           	
                                           
                                           	code
                                           	global InitLCD,WrtLCD,ClkLCD,ClrLCD,PosLCD		;Only these functions are visible to other asm files.
                                               ;***********************************
                                           InitLCD
                                           
                                           	;bsf PORTD,E     ;E default high
                                           	
                                           	;Wait for LCD POR to finish (~15ms)
000346   ecf5     call	0x3ea, 0            	call lcdLongDelay
000348   f001
00034a   ecf5     call	0x3ea, 0            	call lcdLongDelay
00034c   f001
00034e   ecf5     call	0x3ea, 0            	call lcdLongDelay
000350   f001
                                           
                                           	;Ensure 8-bit mode first (no way to immediately guarantee 4-bit mode)
                                           	; -> Send b'0011' 3 times
000352   9483     bcf	0x83, 0x2, 0             bcf     PORTD,RS       ;Instruction mode
000354   0e30     movlw	0x30               	movlw   B'00110000'
000356   ecf0     call	0x3e0, 0            	call    MovMSB
000358   f001
00035a   ece1     call	0x3c2, 0            	call    ClkLCD         ;Finish last 4-bit send (if reset occurred in middle of a send)
00035c   f001
00035e   ece1     call	0x3c2, 0            	call    ClkLCD         ;Assuming 4-bit mode, set 8-bit mode
000360   f001
000362   ecf5     call	0x3ea, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
000364   f001
000366   ece1     call	0x3c2, 0            	call    ClkLCD         ;(note: if it's in 8-bit mode already, it will stay in 8-bit mode)
000368   f001
                                           
                                               ;Now that we know for sure it's in 8-bit mode, set 4-bit mode.
00036a   0e20     movlw	0x20               	movlw B'00100000'
00036c   ecf0     call	0x3e0, 0            	call MovMSB
00036e   f001
000370   ece1     call	0x3c2, 0            	call ClkLCD
000372   f001
000374   ecf5     call	0x3ea, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
000376   f001
                                           	;Give LCD init instructions
                                           	WRT_LCD B'00101000' ; 4 bits, 2 lines,5X8 dot
00037e   ecf5     call	0x3ea, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
000380   f001
                                           	WRT_LCD B'00001111' ; display on,cursor,blink
000388   ecf5     call	0x3ea, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
00038a   f001
                                           	WRT_LCD B'00000110' ; Increment,no shift
000392   ecf5     call	0x3ea, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
000394   f001
                                           	;Ready to display characters
000396   ecda     call	0x3b4, 0            	call    ClrLCD
000398   f001
00039a   8483     bsf	0x83, 0x2, 0             bsf     PORTD,RS    ;Character mode
00039c   0012     return	0                 	return
                                               ;************************************
                                           
                                           	;WrtLCD: Clock MSB and LSB of W to PORTD<7:4> in two cycles
                                           WrtLCD
00039e   6f80     movwf	0x80, 0x1          	movwf   lcd_tmp ; store original value
0003a0   ecf0     call	0x3e0, 0            	call    MovMSB  ; move MSB to PORTD
0003a2   f001
0003a4   ece1     call	0x3c2, 0            	call    ClkLCD
0003a6   f001
0003a8   3980     swapf	0x80, 0, 0x1       	swapf   lcd_tmp,w ; Swap LSB of value into MSB of W
0003aa   ecf0     call	0x3e0, 0                call    MovMSB    ; move to PORTD
0003ac   f001
0003ae   ece1     call	0x3c2, 0                call    ClkLCD
0003b0   f001
                                           
0003b2   0012     return	0                     return
                                           
                                               ;ClrLCD: Clear the LCD display
                                           ClrLCD
0003b4   9483     bcf	0x83, 0x2, 0             bcf     PORTD,RS       ;Instruction mode
                                               WRT_LCD b'00000001'
0003bc   ecf5     call	0x3ea, 0                call    lcdLongDelay
0003be   f001
0003c0   0012     return	0                     return
                                           
                                               ;ClkLCD: Pulse the E line low
                                           ClkLCD
                                               ;LCD_DELAY
0003c2   8683     bsf	0x83, 0x3, 0             bsf PORTD,E
0003c4   0000     nop                          nop
                                           	;LCD_DELAY   ; __    __
0003c6   9683     bcf	0x83, 0x3, 0             bcf PORTD,E ;   |__|
                                           	LCD_DELAY
0003d2   0012     return	0                     return
                                           
                                               ;position the cursor at position W. If W=b'010000000', skips to new line
                                           PosLCD
                                               ;****************************************
0003d4   0000     nop                          nop
0003d6   9483     bcf	0x83, 0x2, 0             bcf	PORTD, RS		;sets command mode
0003d8   0b80     andlw	0x80                   andlw b'10000000'		;add 1000 0000
0003da   eccf     call	0x39e, 0                call WrtLCD			;send to LCD
0003dc   f001
0003de   8483     bsf	0x83, 0x2, 0             bsf PORTD, RS
                                               
                                           
                                               ;MovMSB: Move MSB of W to PORTD, without disturbing LSB
                                           MovMSB
0003e0   0bf0     andlw	0xf0                   andlw 0xF0
0003e2   1283     iorwf	0x83, 0x1, 0           iorwf PORTD,f
0003e4   090f     iorlw	0xf                    iorlw 0x0F
0003e6   1683     andwf	0x83, 0x1, 0           andwf PORTD,f
0003e8   0012     return	0                     return
                                           
                                               ;Delay: ~5ms
                                           lcdLongDelay
0003ea   0e50     movlw	0x50                   movlw d'80'
0003ec   6f82     movwf	0x82, 0x1              movwf lcd_d2
                                           LLD_LOOP
                                               LCD_DELAY
0003f8   2f82     decfsz	0x82, 0x1, 0x1        decfsz lcd_d2,f
0003fa   eff7     goto	0x3ee                   goto LLD_LOOP
0003fc   f001
0003fe   0012     return	0                     return
                                               
                                           end
