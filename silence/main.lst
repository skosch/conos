gplink-0.13.7 beta
Copyright (c) 1998-2005 gputils project
Listing File Generated: 1-14-2011  21:57:02
 
 
Address  Value    Disassembly              Source
-------  -----    -----------              ------
                                           list P=18F4620, F=INHX32, C=160, N=80, ST=OFF, MM=OFF, R=DEC
                                           
                                           #include <p18f4620.inc>
                                                   LIST
                                           
                                           ;==========================================================================
                                           ;  MPASM PIC18F4620 processor include
                                           ; 
                                           ;  (c) Copyright 1999-2007 Microchip Technology, All rights reserved
                                           ;==========================================================================
                                           
                                                   NOLIST
                                           #include <lcd18.inc>
                                           	extern	InitLCD,WrtLCD,ClrLCD,ClkLCD
                                           
                                           
                                           ;;;;;;Configuration Bits;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                           
                                           		CONFIG OSC=HS, FCMEN=OFF, IESO=OFF
                                           		CONFIG PWRT = OFF, BOREN = SBORDIS, BORV = 3
                                           		CONFIG WDT = OFF, WDTPS = 32768
                                           		CONFIG MCLRE = ON, LPT1OSC = OFF, PBADEN = OFF, CCP2MX = PORTC
                                           		CONFIG STVREN = ON, LVP = OFF, XINST = OFF
                                           		CONFIG DEBUG = OFF
                                           		CONFIG CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF
                                           		CONFIG CPB = OFF, CPD = OFF
                                           		CONFIG WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
                                           		CONFIG WRTB = OFF, WRTC = OFF, WRTD = OFF
                                           		CONFIG EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
                                           		CONFIG EBTRB = OFF
                                           
                                           
                                           	udata
                                           state	res 1
                                           
                                           ;;;;;;Vectors;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                           	org		0x0000
                                           	
                                           	
000000   ef17     goto	0x2e                	goto	Init
000002   f000
                                           	
                                           	org		0x08				;high priority ISR
000008   ef0d     goto	0x1a                	goto IHR
00000a   f000
                                           
                                           	org		0x18				;low priority ISR
000018   0010     retfie	0                 	retfie
                                           
                                           	code
                                           
                                           IHR
00001a   3881     swapf	0x81, 0, 0         	swapf	PORTB,W		;read PortB<7:4> into W<3:0>
00001c   0b0f     andlw	0xf                	andlw	0x0F		;mask the lower nibble
00001e   44e8     rlncf	0xe8, 0, 0         	rlncf	WREG, W		;program memory counts up by two
000020   ec28     call	0x50, 0             	call	KPHexToChar
000022   f000
000024   ec68     call	0xd0, 0             	call	WrtLCD		;write to LCD
000026   f000
000028   5281     movf	0x81, 0x1, 0        	movf	PORTB, f
00002a   90f0     bcf	0xf0, 0, 0           	bcf	INTCON3, INT1IF	;clear RB1 interrupt bit
                                           
                                           	
00002c   0010     retfie	0                 	retfie
                                           	
                                           Init
00002e   6af2     clrf	0xf2, 0             	clrf	INTCON		; no interrupts
000030   6a92     clrf	0x92, 0             	clrf	TRISA		; PORTA is output
000032   0ef2     movlw	0xf2               	movlw	b'11110010'	; Keypad inputs on Port B
000034   6e93     movwf	0x93, 0            	movwf	TRISB
000036   6a94     clrf	0x94, 0             	clrf	TRISC
000038   6a95     clrf	0x95, 0             	clrf	TRISD
                                           
00003a   6a89     clrf	0x89, 0             	clrf	LATA
00003c   6a8a     clrf	0x8a, 0             	clrf	LATB
00003e   6a8b     clrf	0x8b, 0             	clrf	LATC
000040   6a8c     clrf	0x8c, 0             	clrf	LATD
                                           
000042   ec3c     call	0x78, 0             	call	InitLCD		; Initializes the LCD
000044   f000
000046   86f0     bsf	0xf0, 0x3, 0         	bsf	INTCON3, INT1IE
000048   8af1     bsf	0xf1, 0x5, 0         	bsf	INTCON2, INTEDG1 ; enable RB1 interrupts
00004a   8ef2     bsf	0xf2, 0x7, 0         	bsf	INTCON, GIE
                                           
                                           
00004c   ef3a     goto	0x74                	goto	Mainline
00004e   f000
                                           	
                                           
                                           KPHexToChar
000050   26f9     addwf	0xf9, 0x1, 0       	addwf	PCL,f
000052   0c31     retlw	0x31               	dt	"123A456B789C*0#D"
000054   0c32     retlw	0x32               
000056   0c33     retlw	0x33               
000058   0c41     retlw	0x41               
00005a   0c34     retlw	0x34               
00005c   0c35     retlw	0x35               
00005e   0c36     retlw	0x36               
000060   0c42     retlw	0x42               
000062   0c37     retlw	0x37               
000064   0c38     retlw	0x38               
000066   0c39     retlw	0x39               
000068   0c43     retlw	0x43               
00006a   0c2a     retlw	0x2a               
00006c   0c30     retlw	0x30               
00006e   0c23     retlw	0x23               
000070   0c44     retlw	0x44               
000072   0012     return	0                 	return
                                           
                                           Mainline
                                           
000074   ef3a     goto	0x74                	goto	$
000076   f000
                                           	
                                           end
                                           #include <p18f4620.inc>
                                                   LIST
                                           
                                           ;==========================================================================
                                           ;  MPASM PIC18F4620 processor include
                                           ; 
                                           ;  (c) Copyright 1999-2007 Microchip Technology, All rights reserved
                                           ;==========================================================================
                                           
                                                   NOLIST
                                           	
                                           	;Declare unbanked variables (at 0x70 and on)
                                           	udata
                                           lcd_tmp	res	1
                                           lcd_d1	res	1
                                           lcd_d2	res	1
                                           
                                           	;Declare constants for pin assignments (LCD on PORTD)
                                           RS 	equ 2
                                           E 	equ 3
                                           
                                           	;Helper macros
                                           WRT_LCD macro val
0000aa   0e28     movlw	0x28               	movlw   val
0000ac   ec68     call	0xd0, 0             	call    WrtLCD
0000ae   f000
                                           	endm
                                           	
                                           ;Delay: ~44us
                                           LCD_DELAY macro
0000fa   0e23     movlw	0x23               	movlw   0x23
0000fc   6f82     movwf	0x82, 0x1          	movwf   lcd_d1
0000fe   2f82     decfsz	0x82, 0x1, 0x1    	decfsz  lcd_d1,f
000100   ef7f     goto	0xfe                	goto    $-2
000102   f000
                                           	endm
                                           	
                                           
                                           	code
                                           	global InitLCD,WrtLCD,ClkLCD,ClrLCD		;Only these functions are visible to other asm files.
                                               ;***********************************
                                           InitLCD
                                           
                                           	;bsf PORTD,E     ;E default high
                                           	
                                           	;Wait for LCD POR to finish (~15ms)
000078   ec88     call	0x110, 0            	call lcdLongDelay
00007a   f000
00007c   ec88     call	0x110, 0            	call lcdLongDelay
00007e   f000
000080   ec88     call	0x110, 0            	call lcdLongDelay
000082   f000
                                           
                                           	;Ensure 8-bit mode first (no way to immediately guarantee 4-bit mode)
                                           	; -> Send b'0011' 3 times
000084   9483     bcf	0x83, 0x2, 0             bcf     PORTD,RS       ;Instruction mode
000086   0e30     movlw	0x30               	movlw   B'00110000'
000088   ec83     call	0x106, 0            	call    MovMSB
00008a   f000
00008c   ec7a     call	0xf4, 0             	call    ClkLCD         ;Finish last 4-bit send (if reset occurred in middle of a send)
00008e   f000
000090   ec7a     call	0xf4, 0             	call    ClkLCD         ;Assuming 4-bit mode, set 8-bit mode
000092   f000
000094   ec88     call	0x110, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
000096   f000
000098   ec7a     call	0xf4, 0             	call    ClkLCD         ;(note: if it's in 8-bit mode already, it will stay in 8-bit mode)
00009a   f000
                                           
                                               ;Now that we know for sure it's in 8-bit mode, set 4-bit mode.
00009c   0e20     movlw	0x20               	movlw B'00100000'
00009e   ec83     call	0x106, 0            	call MovMSB
0000a0   f000
0000a2   ec7a     call	0xf4, 0             	call ClkLCD
0000a4   f000
0000a6   ec88     call	0x110, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
0000a8   f000
                                           	;Give LCD init instructions
                                           	WRT_LCD B'00101000' ; 4 bits, 2 lines,5X8 dot
0000b0   ec88     call	0x110, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
0000b2   f000
                                           	WRT_LCD B'00001111' ; display on,cursor,blink
0000ba   ec88     call	0x110, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
0000bc   f000
                                           	WRT_LCD B'00000110' ; Increment,no shift
0000c4   ec88     call	0x110, 0            	call    lcdLongDelay   ;->max instruction time ~= 5ms
0000c6   f000
                                           	;Ready to display characters
0000c8   ec73     call	0xe6, 0             	call    ClrLCD
0000ca   f000
0000cc   8483     bsf	0x83, 0x2, 0             bsf     PORTD,RS    ;Character mode
0000ce   0012     return	0                 	return
                                               ;************************************
                                           
                                           	;WrtLCD: Clock MSB and LSB of W to PORTD<7:4> in two cycles
                                           WrtLCD
0000d0   6f81     movwf	0x81, 0x1          	movwf   lcd_tmp ; store original value
0000d2   ec83     call	0x106, 0            	call    MovMSB  ; move MSB to PORTD
0000d4   f000
0000d6   ec7a     call	0xf4, 0             	call    ClkLCD
0000d8   f000
0000da   3981     swapf	0x81, 0, 0x1       	swapf   lcd_tmp,w ; Swap LSB of value into MSB of W
0000dc   ec83     call	0x106, 0                call    MovMSB    ; move to PORTD
0000de   f000
0000e0   ec7a     call	0xf4, 0                 call    ClkLCD
0000e2   f000
                                           
0000e4   0012     return	0                     return
                                           
                                               ;ClrLCD: Clear the LCD display
                                           ClrLCD
0000e6   9483     bcf	0x83, 0x2, 0             bcf     PORTD,RS       ;Instruction mode
                                               WRT_LCD b'00000001'
0000ee   ec88     call	0x110, 0                call    lcdLongDelay
0000f0   f000
0000f2   0012     return	0                     return
                                           
                                               ;ClkLCD: Pulse the E line low
                                           ClkLCD
                                               ;LCD_DELAY
0000f4   8683     bsf	0x83, 0x3, 0             bsf PORTD,E
0000f6   0000     nop                          nop
                                           	;LCD_DELAY   ; __    __
0000f8   9683     bcf	0x83, 0x3, 0             bcf PORTD,E ;   |__|
                                           	LCD_DELAY
000104   0012     return	0                     return
                                           
                                               ;****************************************
                                           
                                               ;MovMSB: Move MSB of W to PORTD, without disturbing LSB
                                           MovMSB
000106   0bf0     andlw	0xf0                   andlw 0xF0
000108   1283     iorwf	0x83, 0x1, 0           iorwf PORTD,f
00010a   090f     iorlw	0xf                    iorlw 0x0F
00010c   1683     andwf	0x83, 0x1, 0           andwf PORTD,f
00010e   0012     return	0                     return
                                           
                                               ;Delay: ~5ms
                                           lcdLongDelay
000110   0e50     movlw	0x50                   movlw d'80'
000112   6f83     movwf	0x83, 0x1              movwf lcd_d2
                                           LLD_LOOP
                                               LCD_DELAY
00011e   2f83     decfsz	0x83, 0x1, 0x1        decfsz lcd_d2,f
000120   ef8a     goto	0x114                   goto LLD_LOOP
000122   f000
000124   0012     return	0                     return
                                               
                                               end
                                           ;
                                           ;  PIC macro library
                                           ;  Developed by Karl Lunt, May 1999
                                           ;
                                           
                                           ;
                                           ;  This library provides macros for program structures such
                                           ;  as FOR-NEXT, REPEAT-ALWAYS, REPEAT-UNTIL, and others.
                                           ;
                                           ;  To incorporate this library in your PIC assembler program,
                                           ;  add the following INCLUDE statement immediately after the
                                           ;  INCLUDE statement that adds the Microchip equates for your
                                           ;  specific processor:
                                           ;
                                           ;	include		"macros.asm"
                                           ;
                                           ;  For example, if you are developing code for the 12c672,
                                           ;  you would use equates similar to:
                                           ;
                                           ;	include		".\p12c672.inc"
                                           ;	include		".\macros.asm"
                                           ;
                                           
                                           ;
                                           ;  Version 1.0   29 May 1999
                                           ;  Initial release.  Includes WAITWHILE, WAITUNTIL, and POLL-ENDPOLL.
                                           ;  Changed movfw to movf, to support older MCUs.  Will still give errors
                                           ;  in NEXTL macro on older PICs, since that macro uses the addlw
                                           ;  instruction.
                                           ;
                                           
                                           
                                           ;
                                           ;  Declare some variables used by the macro library.
                                           ;
                                           
                                           	variable	_forknt=0
                                           	variable	_nxtknt=0
                                           	variable	_rptknt=0
                                           	variable	_alwknt=0
                                           	variable	_untknt=0
                                           	variable	_seltot=0
                                           	variable	_selknt=0
                                           	variable	_castot=0
                                           	variable	_casknt=0
                                           	variable	_waitk=0
                                           	variable	_pollk=0
                                           	variable	_pollt=0
                                           
                                           
                                           
                                           ;
                                           ;  Define the BEQ (branch-if-equal)
                                           ;
                                           ;  Syntax:
                                           ;		beq	label
                                           ;
                                           ;  The BEQ macro tests the current state of the Z-bit.  It
                                           ;  does not alter W or any registers.
                                           ;
                                           
                                           beq	macro	addr
                                           	btfsc	STATUS,Z
                                           	goto	addr
                                           	endm
                                           
                                           
                                           ;
                                           ;  BNE (branch-if-not-equal)
                                           ;
                                           ;  Syntax:
                                           ;		bne	label
                                           ;
                                           ;  The BNE macro tests the current state of the Z-bit.  It
                                           ;  does not alter W or any registers.
                                           ;
                                           
                                           bne	macro	addr
                                           	btfss	STATUS,Z
                                           	goto	addr
                                           	endm
                                           
                                           
                                           ;
                                           ;  FOR (start of FOR-NEXT loop)
                                           ;
                                           ;  Syntax:
                                           ;		for	var,begl,endl
                                           ;
                                           ;  The FOR macro starts a FOR-NEXT loop.  The arguments are:
                                           ;  var is a RAM variable used as the loop index,
                                           ;  begl is a literal value used as the initial index value,
                                           ;  endl is a literal value used as the ending index value.
                                           ;
                                           ;  Control will run through the FOR-NEXT loop until the value
                                           ;  in var EQUALS the endl literal value; the value is tested
                                           ;  at the top of the loop.  At this point, control exits the
                                           ;  loop at the corresponding NEXT macro.
                                           ;
                                           ;  This macro destroys the contents of the W register.
                                           ;
                                           ;  You may terminate a FOR loop with NEXT, NEXTL, or NEXTF.
                                           ;
                                           
                                           for	macro	var,begl,endl
                                           	movlw	begl
                                           	movwf	var
                                           _for#v(_forknt)
                                           	movlw	endl
                                           	subwf	var,w
                                           ;	movf	var,w
                                           ;	sublw	endl
                                           	beq	_next#v(_forknt)
                                           _forknt	set	_forknt+1
                                           _nxtknt	set	_forknt
                                           	endm
                                           
                                           
                                           ;
                                           ;  FORF (start of FORF-NEXT loop)
                                           ;
                                           ;  Syntax:
                                           ;		forf	var,begl,endf
                                           ;
                                           ;  The FORF macro starts a FORF-NEXT loop.  The arguments are:
                                           ;  var is a RAM variable used as the loop index,
                                           ;  begl is a literal value used as the initial index value,
                                           ;  endf is a flag or RAM variable used as the ending index
                                           ;  value.
                                           ;
                                           ;  Control will run through the FORF-NEXT loop until the value
                                           ;  in var EQUALS the endf variable value; the value is tested
                                           ;  at the top of the loop.  At this point, control exits the
                                           ;  loop at the corresponding NEXT macro.
                                           ;
                                           ;  This macro destroys the contents of the W register.
                                           ;
                                           ;  You may terminate a FORF loop with NEXT, NEXTL, or NEXTF.
                                           ;
                                           
                                           forf	macro	var,begl,endf
                                           	movlw	begl
                                           	movwf	var
                                           _for#v(_forknt)
                                           	movf	var,w
                                           	subwf	endf
                                           	beq	_next#v(_forknt)
                                           _forknt	set	_forknt+1
                                           _nxtknt	set	_forknt
                                           	endm
                                           
                                           
                                           ;
                                           ;  NEXT (end of a FOR-NEXT loop)
                                           ;
                                           ;  Syntax:
                                           ;		next	var
                                           ;
                                           ;  The NEXT macro terminates a FOR-NEXT loop.  The 
                                           ;  argument is:
                                           ;  var is a RAM variable that is the index of the FOR-NEXT loop.
                                           ;
                                           ;  Control will increment the value in var, then go back to
                                           ;  the top of the FOR-NEXT loop for testing.  Note that the var
                                           ;  argument for the NEXT macro must match the var argument for
                                           ;  the corresponding FOR macro.  The macro library does not perform
                                           ;  this check for you; you have to get it right yourself!
                                           ;
                                           ;  This macro alters the contents of the W register and the index
                                           ;  variable var.
                                           ;
                                           ;  You may use NEXT to terminate a FOR-NEXT, FORF-NEXT, or
                                           ;  FORL-NEXT loop.
                                           ;
                                           
                                           next	macro	var
                                           _nxtknt	set	_nxtknt-1
                                           	incf	var,f
                                           	goto	_for#v(_nxtknt)
                                           _next#v(_nxtknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  NEXTL (end of a FOR-NEXTL loop)
                                           ;
                                           ;  Syntax:
                                           ;		nextl	var,incl
                                           ;
                                           ;  The NEXTL macro terminates a FOR-NEXTL loop.  The 
                                           ;  arguments are:
                                           ;  var is a RAM variable that is the index of the FOR-NEXTL loop,
                                           ;  incl is a literal value used to modify the index.
                                           ;
                                           ;  Control will add the literal incl to the value in var, then
                                           ;  go back to the top of the FOR-NEXTL loop for testing.  Note
                                           ;  that the var argument for the NEXTL macro must match the var
                                           ;  argument for the corresponding FOR macro.  The macro library
                                           ;  does not perform this check for you; you have to get it right
                                           ;  yourself!
                                           ;
                                           ;  This macro alters the contents of the W register and the index
                                           ;  variable var.
                                           ;
                                           ;  You may use NEXTL to terminate a FOR-NEXTL, FORF-NEXTL, or
                                           ;  FORL-NEXTL loop.
                                           ;
                                           ;  NOTE:  This macro uses the addlw instruction, which is not
                                           ;  supported on the older PICs, such as the 16c54.  Using this
                                           ;  macro in a source file for such a chip will generate assembler
                                           ;  errors.
                                           ;
                                           
                                           nextl	macro	var,incl
                                           _nxtknt	set	_nxtknt-1
                                           	movf	var,w
                                           	addlw	incl
                                           	movwf	var
                                           	goto	_for#v(_nxtknt)
                                           _next#v(_nxtknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  NEXTF (end of a FOR-NEXTF loop)
                                           ;
                                           ;  Syntax:
                                           ;		nextf	var,incf
                                           ;
                                           ;  The NEXTF macro terminates a FOR-NEXTF loop.  The 
                                           ;  arguments are:
                                           ;  var is a RAM variable that is the index of the FOR-NEXTL loop,
                                           ;  incf is a register whose value is used to modify the index.
                                           ;
                                           ;  Control will add the value in incf to the value in var, then
                                           ;  go back to the top of the FOR-NEXTF loop for testing.  Note
                                           ;  that the var argument for the NEXTF macro must match the var
                                           ;  argument for the corresponding FOR macro.  The macro library
                                           ;  does not perform this check for you; you have to get it right
                                           ;  yourself!
                                           ;
                                           ;  This macro alters the contents of the W register and the index
                                           ;  variable var.
                                           ;
                                           ;  You may use NEXTF to terminate a FOR-NEXTF, FORF-NEXTF, or
                                           ;  FORL-NEXTF loop.
                                           ;
                                           
                                           nextf	macro	var,incf
                                           _nxtknt	set	_nxtknt-1
                                           	movf	var,w
                                           	addwf	incf,f
                                           	goto	_for#v(_nxtknt)
                                           _next#v(_nxtknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  REPEAT (start of a REPEAT-ALWAYS or REPEAT-UNTIL loop)
                                           ;
                                           ;  Syntax:
                                           ;		repeat
                                           ;
                                           ;  The REPEAT macro marks the start of a REPEAT-ALWAYS or
                                           ;  REPEAT-UNTILEQ or REPEAT-UNTILNE loop.  Control will always
                                           ;  return to the start of the REPEAT macro if the loop is
                                           ;  terminated with an ALWAYS macro.  Control will conditionally
                                           ;  return to the start of the REPEAT macro if the loop is
                                           ;  terminated with an UNTILEQ or UNTILNE macro.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           repeat	macro
                                           _rpt#v(_rptknt)
                                           _rptknt	set	_rptknt+1
                                           _alwknt	set	_rptknt
                                           _untknt	set	_rptknt
                                           	endm
                                           
                                           
                                           ;
                                           ;  ALWAYS (returns to corresponding REPEAT macro)
                                           ;
                                           ;  Syntax:
                                           ;		always
                                           ;
                                           ;  The ALWAYS macro marks the end of a REPEAT-ALWAYS loop.
                                           ;  Control is automatically passed back to the corresponding
                                           ;  REPEAT macro.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           always	macro
                                           _alwknt	set	_alwknt-1
                                           	goto	_rpt#v(_alwknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  UNTILEQ (conditionally returns to corresponding REPEAT macro)
                                           ;
                                           ;  Syntax:
                                           ;		untileq
                                           ;
                                           ;  The UNTILEQ macro marks the end of a REPEAT-UNTILEQ loop.
                                           ;  Control is passed back to the corresponding REPEAT macro only
                                           ;  if the Z-bit is cleared at the time the UNTILEQ macro is
                                           ;  processed.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           untileq	macro
                                           _untknt	set	_untknt-1
                                           	bne	_rpt#v(_untknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  UNTILNE (conditionally returns to corresponding REPEAT macro)
                                           ;
                                           ;  Syntax:
                                           ;		untilne
                                           ;
                                           ;  The UNTILEQ macro marks the end of a REPEAT-UNTILNE loop.
                                           ;  Control is passed back to the corresponding REPEAT macro only
                                           ;  if the Z-bit is set at the time the UNTILNE macro is processed.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           untilne	macro
                                           _untknt	set	_untknt-1
                                           	beq	_rpt#v(_untknt)
                                           	endm
                                           
                                           
                                           ;
                                           ;  SELECT (declares start of SELECT-ENDSELECT structure)
                                           ;
                                           ;  Syntax:
                                           ;		select
                                           ;
                                           ;  The SELECT macro marks the beginning of a SELECT-ENDSELECT
                                           ;  structure.  A typical SELECT-ENDSELECT structure looks like this:
                                           ;
                                           ;	select			; start of SELECT block
                                           ;	case	5		; if W = 5...
                                           ;	  .			; do something
                                           ;	endcase			; end of W = 5 clause
                                           ;	casef	foo		; if W = foo
                                           ;	  .			; do something else
                                           ;	endcase			; end of W = foo clause
                                           ;	  .			; default action (all cases fail)
                                           ;	endselect		; end of SELECT block
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           select	macro
                                           _seltot	set	_seltot+1
                                           _selknt	set	_seltot
                                           	endm
                                           
                                           
                                           ;
                                           ;  ENDSELECT (declares end of SELECT-ENDSELECT structure)
                                           ;
                                           ;  Syntax:
                                           ;		endselect
                                           ;
                                           ;  The ENDSELECT macro marks the end of a SELECT-ENDSELECT
                                           ;  structure.  You must terminate each SELECT macro with
                                           ;  a matching ENDSELECT macro or MPASM will report errors.
                                           ;
                                           ;  This macro does not alter the W register.
                                           ;
                                           
                                           endselect	macro
                                           sel#v(_selknt)
                                           _selknt	set	_selknt-1
                                           	endm
                                           
                                           
                                           ;
                                           ;  CASE (declares start of a CASE-ENDCASE structure)
                                           ;
                                           ;  Syntax:
                                           ;		case	lit
                                           ;
                                           ;  where lit is a literal value used as the CASE selector.
                                           ;
                                           ;  When the CASE macro is executed, the value in W is compared
                                           ;  with the literal value lit.  If W equals lit, code following
                                           ;  the CASE macro is executed.  If W does not equal lit, control
                                           ;  passes to the code following the corresponding ENDCASE macro.
                                           ;
                                           ;  W is preserved in the CASE macro.
                                           ;
                                           
                                           case	macro	lit
                                           _castot set	_castot+1
                                           _casknt	set	_castot
                                           	xorlw	lit
                                           	beq	cas#v(_casknt)
                                           	xorlw	lit
                                           	goto	ecas#v(_casknt)
                                           cas#v(_casknt)
                                           	xorlw	lit
                                           	endm
                                           
                                           
                                           ;
                                           ;  CASEF (declares start of a CASEF-ENDCASE structure)
                                           ;
                                           ;  Syntax:
                                           ;		casef	var
                                           ;
                                           ;  where var is a register or variable used as the CASEF selector.
                                           ;
                                           ;  When the CASEF macro is executed, the value in W is compared
                                           ;  with the value in var.  If W equals var, code following
                                           ;  the CASEF macro is executed.  If W does not equal var, control
                                           ;  passes to the code following the corresponding ENDCASE macro.
                                           ;
                                           ;  W is preserved in the CASEF macro.
                                           ;
                                           
                                           casef	macro	var
                                           _castot set	_castot+1
                                           _casknt	set	_castot
                                           	xorwf	var,w
                                           	beq	cas#v(_casknt)
                                           	xorwf	var,w
                                           	goto	ecas#v(_casknt)
                                           cas#v(_casknt)
                                           	xorwf	var,w
                                           	endm
                                           
                                           
                                           ;
                                           ;  ENDCASE (declares end of a CASE-ENDCASE or CASEF-ENDCASE structure)
                                           ;
                                           ;  Syntax:
                                           ;		endcase
                                           ;
                                           ;  The ENDCASE macro marks the end of a CASE-ENDCASE or CASEF-ENDCASE
                                           ;  structure.  This macro serves as a jump address for the corresponding
                                           ;  CASE or CASEF macro.
                                           ;
                                           ;  You must have an ENDCASE macro for each CASE or CASEF macro.  If
                                           ;  not, MPASM will report errors when it assembles your code.
                                           ;
                                           ;  This macro preserves the W register.
                                           ;
                                           
                                           endcase	macro
                                           	goto	sel#v(_selknt)
                                           ecas#v(_casknt)
                                           _casknt	set	_casknt-1
                                           	endm
                                           
                                           
                                           ;
                                           ;  WAITWHILE (declares a high-speed WAIT-WHILE loop)
                                           ;
                                           ;  Syntax:
                                           ;
                                           ;  		waitwhile	addr,andl,xorl
                                           ;
                                           ;  The WAITWHILE macro creates a tight loop that reads the byte
                                           ;  in address addr, ANDs it with the literal andl, then XORs the
                                           ;  result with the literal xorl.  If the result is TRUE (non-zero),
                                           ;  the loop repeats.  If the result is FALSE (zero), control exits
                                           ;  the macro.
                                           ;
                                           ;  This macro destroys the W register.  It does not modify addr.
                                           ;
                                           
                                           waitwhile	macro	addr,andl,xorl
                                           waitw#v(_waitk)
                                           	movf	addr,w
                                           	andlw	andl
                                           	if	xorl != 0
                                           	xorlw	xorl
                                           	endif
                                           	bne	waitw#v(_waitk)
                                           _waitk	set	_waitk+1
                                           	endm
                                           
                                           
                                           ;
                                           ;  WAITUNTIL (declares a high-speed WAIT-UNTIL loop)
                                           ;
                                           ;  Syntax:
                                           ;
                                           ;  		waituntil	addr,andl,xorl
                                           ;
                                           ;  The WAITUNTIL macro creates a tight loop that reads the byte
                                           ;  in address addr, ANDs it with the literal andl, then XORs the
                                           ;  result with the literal xorl.  If the result is TRUE (non-zero),
                                           ;  control exits the macro.  If the result is FALSE (zero),
                                           ;  the loop repeats.
                                           ;
                                           ;  This macro destroys the W register.  It does not modify addr.
                                           ;
                                           
                                           
                                           waituntil	macro	addr,andl,xorl
                                           waitw#v(_waitk)
                                           	movf	addr,w
                                           	andlw	andl
                                           	if	xorl != 0
                                           	xorlw	xorl
                                           	endif
                                           	beq	waitw#v(_waitk)
                                           _waitk	set	_waitk+1
                                           	endm
                                           
                                           
                                           ;
                                           ;  POLL (starts a POLL-ENDPOLL structure)
                                           ;
                                           ;  Syntax:
                                           ;
                                           ;  		poll	addr,andl,xorl
                                           ;
                                           ;  The POLL macro reads the byte in address addr, ANDs it with
                                           ;  the literal andl, then XORs the result with the literal xorl.
                                           ;  If the result is TRUE (non-zero), control passes to the code
                                           ;  immediately following the macro.  If the result is FALSE
                                           ;  (zero), control jumps to the corresponding ENDPOLL macro.
                                           ;
                                           ;  For example, the following POLL command will test the address
                                           ;  SPORT for bit 3 high:
                                           ;
                                           ;	poll	SPORT,8,0		test bit 3
                                           ;	nop				do this if bit 3 is high
                                           ;	endpoll
                                           ;
                                           ;  The following POLL command will test the address SPORT for
                                           ;  bit 3 high while either bits 2 or 1 are low:
                                           ;
                                           ;	poll	SPORT,0x0e,0x06		test bits 1-3
                                           ;	nop				do if 3 is high, 1 or 2 is low
                                           ;	endpoll
                                           ;
                                           ;  This macro destroys the W register.  It does not modify addr.
                                           ;
                                           
                                           
                                           poll	macro	addr,andl,xorl
                                           _pollt	set	_pollt+1
                                           _pollk	set	_pollt
                                           	movf	addr,w
                                           	andlw	andl
                                           	xorlw	xorl
                                           	beq	poll#v(_pollk)
                                           	endm
                                           
                                           
                                           ;
                                           ;  ENDPOLL (marks end of a POLL-ENDPOLL structure)
                                           ;
                                           ;  The ENDPOLL macro terminates a POLL-ENDPOLL structure.
                                           ;  Control reaches this macro if the associated POLL macro
                                           ;  fails.
                                           ;
                                           
                                           endpoll	macro
                                           poll#v(_pollk)
                                           _pollk	set	_pollk-1
                                           
                                           
                                           	;; ****************************************
                                           	;; SEB'S LEGENDARY ADDITIONS
                                           	;; ****************************************
                                           
                                           
                                           endm
                                           end
